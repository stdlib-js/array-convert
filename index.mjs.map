{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isCollection from '@stdlib/assert-is-collection';\nimport getType from '@stdlib/array-dtype';\nimport ctors from '@stdlib/array-ctors';\nimport reinterpret128 from '@stdlib/strided-base-reinterpret-complex128';\nimport reinterpret64 from '@stdlib/strided-base-reinterpret-complex64';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport gcopy from '@stdlib/blas-base-gcopy';\nimport copy from '@stdlib/array-base-copy';\n\n\n// FUNCTIONS //\n\n/**\n* Tests whether a data type is a single-precision complex floating-point number data type.\n*\n* @private\n* @param {string} dtype - data type\n* @returns {boolean} boolean indicating whether a provided data type is a single-precision complex floating-point number data type\n*\n* @example\n* var bool = isComplex64( 'float64' );\n* // returns false\n*\n* @example\n* var bool = isComplex64( 'complex64' );\n* // returns true\n*/\nfunction isComplex64( dtype ) {\n\treturn ( dtype === 'complex64' );\n}\n\n/**\n* Tests whether a data type is a double-precision complex floating-point number data type.\n*\n* @private\n* @param {string} dtype - data type\n* @returns {boolean} boolean indicating whether a provided data type is a double-precision complex floating-point number data type\n*\n* @example\n* var bool = isComplex128( 'float64' );\n* // returns false\n*\n* @example\n* var bool = isComplex128( 'complex128' );\n* // returns true\n*/\nfunction isComplex128( dtype ) {\n\treturn ( dtype === 'complex128' );\n}\n\n\n// MAIN //\n\n/**\n* Converts an array to an array of a different data type.\n*\n* @param {Collection} x - array to convert\n* @param {string} dtype - output data type\n* @throws {TypeError} first argument must be an array-like object\n* @throws {TypeError} second argument must be a recognized array data type\n* @returns {(Array|TypedArray|ComplexArray)} output array\n*\n* @example\n* var arr = [ 1.0, 2.0, 3.0, 4.0 ];\n*\n* var out = convert( arr, 'float64' );\n* // returns <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction convert( x, dtype ) {\n\tvar isc64;\n\tvar ctor;\n\tvar xbuf;\n\tvar obuf;\n\tvar out;\n\tvar len;\n\tvar t;\n\n\tif ( !isCollection( x ) ) {\n\t\tthrow new TypeError( format( '00V2O,GW', x ) );\n\t}\n\t// If the output data type is \"generic\", our task is relatively straightforward...\n\tif ( dtype === 'generic' ) {\n\t\treturn copy( x );\n\t}\n\tctor = ctors( dtype );\n\tif ( ctor === null ) {\n\t\tthrow new TypeError( format( '00V2P,Mp', dtype ) );\n\t}\n\t// Cache the input array length:\n\tlen = x.length;\n\n\t// Get the input array data type:\n\tt = getType( x );\n\tisc64 = isComplex64( t );\n\n\t// Create the output array:\n\tout = new ctor( len );\n\n\t// As the output data type is not \"generic\", we need to explicitly handle complex number input arrays...\n\tif ( isc64 || isComplex128( t ) ) {\n\t\tif ( isc64 ) {\n\t\t\txbuf = reinterpret64( x, 0 );\n\t\t} else {\n\t\t\txbuf = reinterpret128( x, 0 );\n\t\t}\n\t\t// Check whether the output data type is a complex number data type...\n\t\tif ( isComplex64( dtype ) ) { // cmplx => cmplx\n\t\t\tobuf = reinterpret64( out, 0 );\n\t\t\tgcopy( len*2, xbuf, 1, obuf, 1 );\n\t\t\treturn out;\n\t\t}\n\t\tif ( isComplex128( dtype ) ) { // cmplx => cmplx\n\t\t\tobuf = reinterpret128( out, 0 );\n\t\t\tgcopy( len*2, xbuf, 1, obuf, 1 );\n\t\t\treturn out;\n\t\t}\n\t\t// We assume that the output data type is a real number data type, given that we're looking to convert a provided complex number array; in which case, we'll only extract the real components from the complex number input array...\n\t\tgcopy( len, xbuf, 2, out, 1 ); // cmplx => real\n\t\treturn out;\n\t}\n\t// Check whether we need to explicitly handle complex number output arrays...\n\tisc64 = isComplex64( dtype );\n\tif ( isc64 || isComplex128( dtype ) ) {\n\t\tif ( isc64 ) {\n\t\t\tobuf = reinterpret64( out, 0 );\n\t\t} else {\n\t\t\tobuf = reinterpret128( out, 0 );\n\t\t}\n\t\t// We assume that the input data type is a real number data type, given that we're looking to convert to a complex number array; in which case, we'll only set the real components... (WARNING: we're assuming that the output array has been zero-initialized! The imaginary components should be zero!)\n\t\tgcopy( len, x, 1, obuf, 2 ); // real => cmplx\n\t\treturn out;\n\t}\n\t// At this point, we're no longer handling complex number arrays, so we'll just assume that we can perform a straightforward copy...\n\tgcopy( len, x, 1, out, 1 ); // note: `gcopy` is assumed to support arrays using accessors\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default convert;\n"],"names":["isComplex64","dtype","isComplex128","convert","x","isc64","ctor","xbuf","obuf","out","len","t","isCollection","TypeError","format","copy","ctors","length","getType","reinterpret64","reinterpret128","gcopy"],"mappings":";;ovBAiDA,SAASA,EAAaC,GACrB,MAAmB,cAAVA,CACV,CAiBA,SAASC,EAAcD,GACtB,MAAmB,eAAVA,CACV,CAoBA,SAASE,EAASC,EAAGH,GACpB,IAAII,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,IAAMC,EAAcR,GACnB,MAAM,IAAIS,UAAWC,EAAQ,WAAYV,IAG1C,GAAe,YAAVH,EACJ,OAAOc,EAAMX,GAGd,GAAc,QADdE,EAAOU,EAAOf,IAEb,MAAM,IAAIY,UAAWC,EAAQ,WAAYb,IAa1C,OAVAS,EAAMN,EAAEa,OAIRZ,EAAQL,EADRW,EAAIO,EAASd,IAIbK,EAAM,IAAIH,EAAMI,GAGXL,GAASH,EAAcS,IAE1BJ,EADIF,EACGc,EAAef,EAAG,GAElBgB,EAAgBhB,EAAG,GAGtBJ,EAAaC,IACjBO,EAAOW,EAAeV,EAAK,GAC3BY,EAAW,EAAJX,EAAOH,EAAM,EAAGC,EAAM,GACtBC,GAEHP,EAAcD,IAClBO,EAAOY,EAAgBX,EAAK,GAC5BY,EAAW,EAAJX,EAAOH,EAAM,EAAGC,EAAM,GACtBC,IAGRY,EAAOX,EAAKH,EAAM,EAAGE,EAAK,GACnBA,KAGRJ,EAAQL,EAAaC,KACPC,EAAcD,IAE1BO,EADIH,EACGc,EAAeV,EAAK,GAEpBW,EAAgBX,EAAK,GAG7BY,EAAOX,EAAKN,EAAG,EAAGI,EAAM,GACjBC,IAGRY,EAAOX,EAAKN,EAAG,EAAGK,EAAK,GAChBA,EACR"}