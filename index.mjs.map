{"version":3,"file":"index.mjs","sources":["../lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar getType = require( '@stdlib/array-dtype' );\nvar ctors = require( '@stdlib/array-ctors' );\nvar reinterpret128 = require( '@stdlib/strided-base-reinterpret-complex128' );\nvar reinterpret64 = require( '@stdlib/strided-base-reinterpret-complex64' );\nvar gcopy = require( '@stdlib/blas-base-gcopy' );\nvar copy = require( '@stdlib/array-base-copy' );\n\n\n// FUNCTIONS //\n\n/**\n* Tests whether a data type is a single-precision complex floating-point number data type.\n*\n* @private\n* @param {string} dtype - data type\n* @returns {boolean} boolean indicating whether a provided data type is a single-precision complex floating-point number data type\n*\n* @example\n* var bool = isComplex64( 'float64' );\n* // returns false\n*\n* @example\n* var bool = isComplex64( 'complex64' );\n* // returns true\n*/\nfunction isComplex64( dtype ) {\n\treturn ( dtype === 'complex64' );\n}\n\n/**\n* Tests whether a data type is a double-precision complex floating-point number data type.\n*\n* @private\n* @param {string} dtype - data type\n* @returns {boolean} boolean indicating whether a provided data type is a double-precision complex floating-point number data type\n*\n* @example\n* var bool = isComplex128( 'float64' );\n* // returns false\n*\n* @example\n* var bool = isComplex128( 'complex128' );\n* // returns true\n*/\nfunction isComplex128( dtype ) {\n\treturn ( dtype === 'complex128' );\n}\n\n\n// MAIN //\n\n/**\n* Converts an array to an array of a different data type.\n*\n* @param {Collection} x - array to convert\n* @param {string} dtype - output data type\n* @throws {TypeError} first argument must be an array-like object\n* @throws {TypeError} second argument must be a recognized array data type\n* @returns {(Array|TypedArray|ComplexArray)} output array\n*\n* @example\n* var arr = [ 1.0, 2.0, 3.0, 4.0 ];\n*\n* var out = convert( arr, 'float64' );\n* // returns <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction convert( x, dtype ) {\n\tvar isc64;\n\tvar ctor;\n\tvar xbuf;\n\tvar obuf;\n\tvar out;\n\tvar len;\n\tvar t;\n\n\tif ( !isCollection( x ) ) {\n\t\tthrow new TypeError( 'invalid argument. First argument must be an array-like object. Value: `' + x + '`.' );\n\t}\n\t// If the output data type is \"generic\", our task is relatively straightforward...\n\tif ( dtype === 'generic' ) {\n\t\treturn copy( x );\n\t}\n\tctor = ctors( dtype );\n\tif ( ctor === null ) {\n\t\tthrow new TypeError( 'invalid argument. Second argument must be a recognized array data type. Value: `' + dtype + '`.' );\n\t}\n\t// Cache the input array length:\n\tlen = x.length;\n\n\t// Get the input array data type:\n\tt = getType( x );\n\tisc64 = isComplex64( t );\n\n\t// Create the output array:\n\tout = new ctor( len );\n\n\t// As the output data type is not \"generic\", we need to explicitly handle complex number input arrays...\n\tif ( isc64 || isComplex128( t ) ) {\n\t\tif ( isc64 ) {\n\t\t\txbuf = reinterpret64( x, 0 );\n\t\t} else {\n\t\t\txbuf = reinterpret128( x, 0 );\n\t\t}\n\t\t// Check whether the output data type is a complex number data type...\n\t\tif ( isComplex64( dtype ) ) { // cmplx => cmplx\n\t\t\tobuf = reinterpret64( out, 0 );\n\t\t\tgcopy( len*2, xbuf, 1, obuf, 1 );\n\t\t\treturn out;\n\t\t}\n\t\tif ( isComplex128( dtype ) ) { // cmplx => cmplx\n\t\t\tobuf = reinterpret128( out, 0 );\n\t\t\tgcopy( len*2, xbuf, 1, obuf, 1 );\n\t\t\treturn out;\n\t\t}\n\t\t// We assume that the output data type is a real number data type, given that we're looking to convert a provided complex number array; in which case, we'll only extract the real components from the complex number input array...\n\t\tgcopy( len, xbuf, 2, out, 1 ); // cmplx => real\n\t\treturn out;\n\t}\n\t// Check whether we need to explicitly handle complex number output arrays...\n\tisc64 = isComplex64( dtype );\n\tif ( isc64 || isComplex128( dtype ) ) {\n\t\tif ( isc64 ) {\n\t\t\tobuf = reinterpret64( out, 0 );\n\t\t} else {\n\t\t\tobuf = reinterpret128( out, 0 );\n\t\t}\n\t\t// We assume that the input data type is a real number data type, given that we're looking to convert to a complex number array; in which case, we'll only set the real components... (WARNING: we're assuming that the output array has been zero-initialized! The imaginary components should be zero!)\n\t\tgcopy( len, x, 1, obuf, 2 ); // real => cmplx\n\t\treturn out;\n\t}\n\t// At this point, we're no longer handling complex number arrays, so we'll just assume that we can perform a straightforward copy...\n\tgcopy( len, x, 1, out, 1 ); // note: `gcopy` is assumed to support arrays using accessors\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = convert;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Convert an array to an array of a different data type.\n*\n* @module @stdlib/array-convert\n*\n* @example\n* var convert = require( '@stdlib/array-convert' );\n*\n* var arr = [ 1.0, 2.0, 3.0, 4.0 ];\n*\n* var out = convert( arr, 'float64' );\n* // returns <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],"names":["isCollection","require$$0","getType","require$$1","ctors","require$$2","reinterpret128","require$$3","reinterpret64","require$$4","gcopy","require$$5","copy","require$$6","isComplex64","dtype","isComplex128","lib","x","isc64","ctor","xbuf","obuf","out","len","t","TypeError","length"],"mappings":";;ymBAsBA,IAAIA,EAAeC,EACfC,EAAUC,EACVC,EAAQC,EACRC,EAAiBC,EACjBC,EAAgBC,EAChBC,EAAQC,EACRC,EAAOC,EAoBX,SAASC,EAAaC,GACrB,MAAmB,cAAVA,EAkBV,SAASC,EAAcD,GACtB,MAAmB,eAAVA,EA6FV,ICxHAE,EDgDA,SAAkBC,EAAGH,GACpB,IAAII,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,IAAMzB,EAAckB,GACnB,MAAM,IAAIQ,UAAW,0EAA4ER,EAAI,MAGtG,GAAe,YAAVH,EACJ,OAAOH,EAAMM,GAGd,GAAc,QADdE,EAAOhB,EAAOW,IAEb,MAAM,IAAIW,UAAW,mFAAqFX,EAAQ,MAanH,OAVAS,EAAMN,EAAES,OAIRR,EAAQL,EADRW,EAAIvB,EAASgB,IAIbK,EAAM,IAAIH,EAAMI,GAGXL,GAASH,EAAcS,IAE1BJ,EADIF,EACGX,EAAeU,EAAG,GAElBZ,EAAgBY,EAAG,GAGtBJ,EAAaC,IACjBO,EAAOd,EAAee,EAAK,GAC3Bb,EAAW,EAAJc,EAAOH,EAAM,EAAGC,EAAM,GACtBC,GAEHP,EAAcD,IAClBO,EAAOhB,EAAgBiB,EAAK,GAC5Bb,EAAW,EAAJc,EAAOH,EAAM,EAAGC,EAAM,GACtBC,IAGRb,EAAOc,EAAKH,EAAM,EAAGE,EAAK,GACnBA,KAGRJ,EAAQL,EAAaC,KACPC,EAAcD,IAE1BO,EADIH,EACGX,EAAee,EAAK,GAEpBjB,EAAgBiB,EAAK,GAG7Bb,EAAOc,EAAKN,EAAG,EAAGI,EAAM,GACjBC,IAGRb,EAAOc,EAAKN,EAAG,EAAGK,EAAK,GAChBA"}