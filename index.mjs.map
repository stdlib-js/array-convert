{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isCollection from '@stdlib/assert-is-collection';\nimport getType from '@stdlib/array-dtype';\nimport ctors from '@stdlib/array-ctors';\nimport reinterpret128 from '@stdlib/strided-base-reinterpret-complex128';\nimport reinterpret64 from '@stdlib/strided-base-reinterpret-complex64';\nimport reinterpretBoolean from '@stdlib/strided-base-reinterpret-boolean';\nimport gcopy from '@stdlib/blas-base-gcopy';\nimport copy from '@stdlib/array-base-copy';\nimport resolveGetter from '@stdlib/array-base-resolve-getter';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// FUNCTIONS //\n\n/**\n* Tests whether a data type is a single-precision complex floating-point number data type.\n*\n* @private\n* @param {string} dtype - data type\n* @returns {boolean} boolean indicating whether a provided data type is a single-precision complex floating-point number data type\n*\n* @example\n* var bool = isComplex64( 'float64' );\n* // returns false\n*\n* @example\n* var bool = isComplex64( 'complex64' );\n* // returns true\n*/\nfunction isComplex64( dtype ) {\n\treturn ( dtype === 'complex64' );\n}\n\n/**\n* Tests whether a data type is a double-precision complex floating-point number data type.\n*\n* @private\n* @param {string} dtype - data type\n* @returns {boolean} boolean indicating whether a provided data type is a double-precision complex floating-point number data type\n*\n* @example\n* var bool = isComplex128( 'float64' );\n* // returns false\n*\n* @example\n* var bool = isComplex128( 'complex128' );\n* // returns true\n*/\nfunction isComplex128( dtype ) {\n\treturn ( dtype === 'complex128' );\n}\n\n/**\n* Tests whether a data type is a boolean data type.\n*\n* @private\n* @param {string} dtype - data type\n* @returns {boolean} boolean indicating whether a provided data type is a boolean data type\n*\n* @example\n* var bool = isBool( 'bool' );\n* // returns true\n*\n* @example\n* var bool = isBool( 'complex128' );\n* // returns false\n*/\nfunction isBool( dtype ) {\n\treturn ( dtype === 'bool' );\n}\n\n\n// MAIN //\n\n/**\n* Converts an array to an array of a different data type.\n*\n* @param {Collection} x - array to convert\n* @param {string} dtype - output data type\n* @throws {TypeError} first argument must be an array-like object\n* @throws {TypeError} second argument must be a recognized array data type\n* @returns {(Array|TypedArray|ComplexArray)} output array\n*\n* @example\n* var arr = [ 1.0, 2.0, 3.0, 4.0 ];\n*\n* var out = convert( arr, 'float64' );\n* // returns <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction convert( x, dtype ) {\n\tvar isc64;\n\tvar ctor;\n\tvar xbuf;\n\tvar obuf;\n\tvar get;\n\tvar out;\n\tvar len;\n\tvar t;\n\tvar i;\n\n\tif ( !isCollection( x ) ) {\n\t\tthrow new TypeError( format( '00V2O', x ) );\n\t}\n\t// If the output data type is \"generic\", our task is relatively straightforward...\n\tif ( dtype === 'generic' ) {\n\t\treturn copy( x );\n\t}\n\tctor = ctors( dtype );\n\tif ( ctor === null ) {\n\t\tthrow new TypeError( format( '00V2P', dtype ) );\n\t}\n\t// Cache the input array length:\n\tlen = x.length;\n\n\t// Get the input array data type:\n\tt = getType( x );\n\tisc64 = isComplex64( t );\n\n\t// Create the output array:\n\tout = new ctor( len );\n\n\t// As the output data type is not \"generic\", we need to explicitly handle complex number input arrays...\n\tif ( isc64 || isComplex128( t ) ) {\n\t\tif ( isc64 ) {\n\t\t\txbuf = reinterpret64( x, 0 );\n\t\t} else {\n\t\t\txbuf = reinterpret128( x, 0 );\n\t\t}\n\t\t// Check whether the output data type is a complex number data type...\n\t\tif ( isComplex64( dtype ) ) { // cmplx => cmplx\n\t\t\tobuf = reinterpret64( out, 0 );\n\t\t\tgcopy( len*2, xbuf, 1, obuf, 1 );\n\t\t\treturn out;\n\t\t}\n\t\tif ( isComplex128( dtype ) ) { // cmplx => cmplx\n\t\t\tobuf = reinterpret128( out, 0 );\n\t\t\tgcopy( len*2, xbuf, 1, obuf, 1 );\n\t\t\treturn out;\n\t\t}\n\t\t// Check whether the output data type is a boolean data type...\n\t\tif ( isBool( dtype ) ) { // cmplx => bool\n\t\t\tobuf = reinterpretBoolean( out, 0 );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t// A complex number is only falsy when both the real and imaginary components are zero...\n\t\t\t\tif ( xbuf[ 2*i ] || xbuf[ (2*i)+1 ] ) {\n\t\t\t\t\tobuf[ i ] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tobuf[ i ] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\t// We assume that the output data type is a real number data type, given that we're looking to convert a provided complex number array; in which case, we'll only extract the real components from the complex number input array...\n\t\tgcopy( len, xbuf, 2, out, 1 ); // cmplx => real\n\t\treturn out;\n\t}\n\t// Check whether the input array is a boolean array...\n\tif ( isBool( t ) ) {\n\t\txbuf = reinterpretBoolean( x, 0 );\n\n\t\t// Check whether the output data type is a boolean data type...\n\t\tif ( isBool( dtype ) ) { // bool => bool\n\t\t\tobuf = reinterpretBoolean( out, 0 );\n\t\t\tgcopy( len, xbuf, 1, obuf, 1 );\n\t\t\treturn out;\n\t\t}\n\t\t// Check whether the output data type is a complex number data type...\n\t\tif ( isComplex64( dtype ) ) { // bool => cmplx\n\t\t\tobuf = reinterpret64( out, 0 );\n\t\t\tgcopy( len, xbuf, 1, obuf, 2 );\n\t\t\treturn out;\n\t\t}\n\t\tif ( isComplex128( dtype ) ) { // bool => cmplx\n\t\t\tobuf = reinterpret128( out, 0 );\n\t\t\tgcopy( len, xbuf, 1, obuf, 2 );\n\t\t\treturn out;\n\t\t}\n\t\tgcopy( len, xbuf, 1, out, 1 ); // bool => real\n\t\treturn out;\n\t}\n\t// Check whether we need to explicitly handle complex number output arrays...\n\tisc64 = isComplex64( dtype );\n\tif ( isc64 || isComplex128( dtype ) ) {\n\t\tif ( isc64 ) {\n\t\t\tobuf = reinterpret64( out, 0 );\n\t\t} else {\n\t\t\tobuf = reinterpret128( out, 0 );\n\t\t}\n\t\t// We assume that the input data type is a real number data type, given that we're looking to convert to a complex number array; in which case, we'll only set the real components... (WARNING: we're assuming that the output array has been zero-initialized! The imaginary components should be zero!)\n\t\tgcopy( len, x, 1, obuf, 2 ); // real => cmplx\n\t\treturn out;\n\t}\n\t// Check whether the output data type is a boolean data type...\n\tif ( isBool( dtype ) ) {\n\t\tobuf = reinterpretBoolean( out, 0 );\n\t\tget = resolveGetter( x );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tif ( get( x, i ) ) {\n\t\t\t\tobuf[ i ] = 1;\n\t\t\t} else {\n\t\t\t\tobuf[ i ] = 0;\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\t// At this point, we're no longer handling complex number or boolean arrays, so we'll just assume that we can perform a straightforward copy...\n\tgcopy( len, x, 1, out, 1 ); // note: `gcopy` is assumed to support arrays using accessors\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default convert;\n"],"names":["isComplex64","dtype","isComplex128","isBool","convert","x","isc64","ctor","xbuf","obuf","get","out","len","t","i","isCollection","TypeError","format","copy","ctors","length","getType","reinterpret64","reinterpret128","gcopy","reinterpretBoolean","resolveGetter"],"mappings":";;08BAmDA,SAASA,EAAaC,GACrB,MAAmB,cAAVA,CACV,CAiBA,SAASC,EAAcD,GACtB,MAAmB,eAAVA,CACV,CAiBA,SAASE,EAAQF,GAChB,MAAmB,SAAVA,CACV,CAoBA,SAASG,EAASC,EAAGJ,GACpB,IAAIK,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,IAAMC,EAAcV,GACnB,MAAM,IAAIW,UAAWC,EAAQ,QAASZ,IAGvC,GAAe,YAAVJ,EACJ,OAAOiB,EAAMb,GAGd,GAAc,QADdE,EAAOY,EAAOlB,IAEb,MAAM,IAAIe,UAAWC,EAAQ,QAAShB,IAavC,GAVAW,EAAMP,EAAEe,OAIRd,EAAQN,EADRa,EAAIQ,EAAShB,IAIbM,EAAM,IAAIJ,EAAMK,GAGXN,GAASJ,EAAcW,GAAM,CAOjC,GALCL,EADIF,EACGgB,EAAejB,EAAG,GAElBkB,EAAgBlB,EAAG,GAGtBL,EAAaC,GAGjB,OAFAQ,EAAOa,EAAeX,EAAK,GAC3Ba,EAAW,EAAJZ,EAAOJ,EAAM,EAAGC,EAAM,GACtBE,EAER,GAAKT,EAAcD,GAGlB,OAFAQ,EAAOc,EAAgBZ,EAAK,GAC5Ba,EAAW,EAAJZ,EAAOJ,EAAM,EAAGC,EAAM,GACtBE,EAGR,GAAKR,EAAQF,GAAU,CAEtB,IADAQ,EAAOgB,EAAoBd,EAAK,GAC1BG,EAAI,EAAGA,EAAIF,EAAKE,IAEhBN,EAAM,EAAEM,IAAON,EAAO,EAAEM,EAAG,GAC/BL,EAAMK,GAAM,EAEZL,EAAMK,GAAM,EAGd,OAAOH,CACP,CAGD,OADAa,EAAOZ,EAAKJ,EAAM,EAAGG,EAAK,GACnBA,CACP,CAED,GAAKR,EAAQU,GAIZ,OAHAL,EAAOiB,EAAoBpB,EAAG,GAGzBF,EAAQF,IACZQ,EAAOgB,EAAoBd,EAAK,GAChCa,EAAOZ,EAAKJ,EAAM,EAAGC,EAAM,GACpBE,GAGHX,EAAaC,IACjBQ,EAAOa,EAAeX,EAAK,GAC3Ba,EAAOZ,EAAKJ,EAAM,EAAGC,EAAM,GACpBE,GAEHT,EAAcD,IAClBQ,EAAOc,EAAgBZ,EAAK,GAC5Ba,EAAOZ,EAAKJ,EAAM,EAAGC,EAAM,GACpBE,IAERa,EAAOZ,EAAKJ,EAAM,EAAGG,EAAK,GACnBA,GAIR,IADAL,EAAQN,EAAaC,KACPC,EAAcD,GAQ3B,OANCQ,EADIH,EACGgB,EAAeX,EAAK,GAEpBY,EAAgBZ,EAAK,GAG7Ba,EAAOZ,EAAKP,EAAG,EAAGI,EAAM,GACjBE,EAGR,GAAKR,EAAQF,GAAU,CAGtB,IAFAQ,EAAOgB,EAAoBd,EAAK,GAChCD,EAAMgB,EAAerB,GACfS,EAAI,EAAGA,EAAIF,EAAKE,IAChBJ,EAAKL,EAAGS,GACZL,EAAMK,GAAM,EAEZL,EAAMK,GAAM,EAGd,OAAOH,CACP,CAGD,OADAa,EAAOZ,EAAKP,EAAG,EAAGM,EAAK,GAChBA,CACR"}