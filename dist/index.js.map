{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar getType = require( '@stdlib/array-dtype' );\nvar ctors = require( '@stdlib/array-ctors' );\nvar reinterpret128 = require( '@stdlib/strided-base-reinterpret-complex128' );\nvar reinterpret64 = require( '@stdlib/strided-base-reinterpret-complex64' );\nvar reinterpretBoolean = require( '@stdlib/strided-base-reinterpret-boolean' );\nvar gcopy = require( '@stdlib/blas-base-gcopy' );\nvar copy = require( '@stdlib/array-base-copy' );\nvar resolveGetter = require( '@stdlib/array-base-resolve-getter' );\nvar format = require( '@stdlib/string-format' );\n\n\n// FUNCTIONS //\n\n/**\n* Tests whether a data type is a single-precision complex floating-point number data type.\n*\n* @private\n* @param {string} dtype - data type\n* @returns {boolean} boolean indicating whether a provided data type is a single-precision complex floating-point number data type\n*\n* @example\n* var bool = isComplex64( 'float64' );\n* // returns false\n*\n* @example\n* var bool = isComplex64( 'complex64' );\n* // returns true\n*/\nfunction isComplex64( dtype ) {\n\treturn ( dtype === 'complex64' );\n}\n\n/**\n* Tests whether a data type is a double-precision complex floating-point number data type.\n*\n* @private\n* @param {string} dtype - data type\n* @returns {boolean} boolean indicating whether a provided data type is a double-precision complex floating-point number data type\n*\n* @example\n* var bool = isComplex128( 'float64' );\n* // returns false\n*\n* @example\n* var bool = isComplex128( 'complex128' );\n* // returns true\n*/\nfunction isComplex128( dtype ) {\n\treturn ( dtype === 'complex128' );\n}\n\n/**\n* Tests whether a data type is a boolean data type.\n*\n* @private\n* @param {string} dtype - data type\n* @returns {boolean} boolean indicating whether a provided data type is a boolean data type\n*\n* @example\n* var bool = isBool( 'bool' );\n* // returns true\n*\n* @example\n* var bool = isBool( 'complex128' );\n* // returns false\n*/\nfunction isBool( dtype ) {\n\treturn ( dtype === 'bool' );\n}\n\n\n// MAIN //\n\n/**\n* Converts an array to an array of a different data type.\n*\n* @param {Collection} x - array to convert\n* @param {string} dtype - output data type\n* @throws {TypeError} first argument must be an array-like object\n* @throws {TypeError} second argument must be a recognized array data type\n* @returns {(Array|TypedArray|ComplexArray)} output array\n*\n* @example\n* var arr = [ 1.0, 2.0, 3.0, 4.0 ];\n*\n* var out = convert( arr, 'float64' );\n* // returns <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*/\nfunction convert( x, dtype ) {\n\tvar isc64;\n\tvar ctor;\n\tvar xbuf;\n\tvar obuf;\n\tvar get;\n\tvar out;\n\tvar len;\n\tvar t;\n\tvar i;\n\n\tif ( !isCollection( x ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an array-like object. Value: `%s`.', x ) );\n\t}\n\t// If the output data type is \"generic\", our task is relatively straightforward...\n\tif ( dtype === 'generic' ) {\n\t\treturn copy( x );\n\t}\n\tctor = ctors( dtype );\n\tif ( ctor === null ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be a recognized array data type. Value: `%s`.', dtype ) );\n\t}\n\t// Cache the input array length:\n\tlen = x.length;\n\n\t// Get the input array data type:\n\tt = getType( x );\n\tisc64 = isComplex64( t );\n\n\t// Create the output array:\n\tout = new ctor( len );\n\n\t// As the output data type is not \"generic\", we need to explicitly handle complex number input arrays...\n\tif ( isc64 || isComplex128( t ) ) {\n\t\tif ( isc64 ) {\n\t\t\txbuf = reinterpret64( x, 0 );\n\t\t} else {\n\t\t\txbuf = reinterpret128( x, 0 );\n\t\t}\n\t\t// Check whether the output data type is a complex number data type...\n\t\tif ( isComplex64( dtype ) ) { // cmplx => cmplx\n\t\t\tobuf = reinterpret64( out, 0 );\n\t\t\tgcopy( len*2, xbuf, 1, obuf, 1 );\n\t\t\treturn out;\n\t\t}\n\t\tif ( isComplex128( dtype ) ) { // cmplx => cmplx\n\t\t\tobuf = reinterpret128( out, 0 );\n\t\t\tgcopy( len*2, xbuf, 1, obuf, 1 );\n\t\t\treturn out;\n\t\t}\n\t\t// Check whether the output data type is a boolean data type...\n\t\tif ( isBool( dtype ) ) { // cmplx => bool\n\t\t\tobuf = reinterpretBoolean( out, 0 );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t// A complex number is only falsy when both the real and imaginary components are zero...\n\t\t\t\tif ( xbuf[ 2*i ] || xbuf[ (2*i)+1 ] ) {\n\t\t\t\t\tobuf[ i ] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tobuf[ i ] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\t// We assume that the output data type is a real number data type, given that we're looking to convert a provided complex number array; in which case, we'll only extract the real components from the complex number input array...\n\t\tgcopy( len, xbuf, 2, out, 1 ); // cmplx => real\n\t\treturn out;\n\t}\n\t// Check whether the input array is a boolean array...\n\tif ( isBool( t ) ) {\n\t\txbuf = reinterpretBoolean( x, 0 );\n\n\t\t// Check whether the output data type is a boolean data type...\n\t\tif ( isBool( dtype ) ) { // bool => bool\n\t\t\tobuf = reinterpretBoolean( out, 0 );\n\t\t\tgcopy( len, xbuf, 1, obuf, 1 );\n\t\t\treturn out;\n\t\t}\n\t\t// Check whether the output data type is a complex number data type...\n\t\tif ( isComplex64( dtype ) ) { // bool => cmplx\n\t\t\tobuf = reinterpret64( out, 0 );\n\t\t\tgcopy( len, xbuf, 1, obuf, 2 );\n\t\t\treturn out;\n\t\t}\n\t\tif ( isComplex128( dtype ) ) { // bool => cmplx\n\t\t\tobuf = reinterpret128( out, 0 );\n\t\t\tgcopy( len, xbuf, 1, obuf, 2 );\n\t\t\treturn out;\n\t\t}\n\t\tgcopy( len, xbuf, 1, out, 1 ); // bool => real\n\t\treturn out;\n\t}\n\t// Check whether we need to explicitly handle complex number output arrays...\n\tisc64 = isComplex64( dtype );\n\tif ( isc64 || isComplex128( dtype ) ) {\n\t\tif ( isc64 ) {\n\t\t\tobuf = reinterpret64( out, 0 );\n\t\t} else {\n\t\t\tobuf = reinterpret128( out, 0 );\n\t\t}\n\t\t// We assume that the input data type is a real number data type, given that we're looking to convert to a complex number array; in which case, we'll only set the real components... (WARNING: we're assuming that the output array has been zero-initialized! The imaginary components should be zero!)\n\t\tgcopy( len, x, 1, obuf, 2 ); // real => cmplx\n\t\treturn out;\n\t}\n\t// Check whether the output data type is a boolean data type...\n\tif ( isBool( dtype ) ) {\n\t\tobuf = reinterpretBoolean( out, 0 );\n\t\tget = resolveGetter( x );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tif ( get( x, i ) ) {\n\t\t\t\tobuf[ i ] = 1;\n\t\t\t} else {\n\t\t\t\tobuf[ i ] = 0;\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\t// At this point, we're no longer handling complex number or boolean arrays, so we'll just assume that we can perform a straightforward copy...\n\tgcopy( len, x, 1, out, 1 ); // note: `gcopy` is assumed to support arrays using accessors\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = convert;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Convert an array to an array of a different data type.\n*\n* @module @stdlib/array-convert\n*\n* @example\n* var convert = require( '@stdlib/array-convert' );\n*\n* var arr = [ 1.0, 2.0, 3.0, 4.0 ];\n*\n* var out = convert( arr, 'float64' );\n* // returns <Float64Array>[ 1.0, 2.0, 3.0, 4.0 ]\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_main", "__commonJSMin", "exports", "module", "isCollection", "getType", "ctors", "reinterpret128", "reinterpret64", "reinterpretBoolean", "gcopy", "copy", "resolveGetter", "format", "isComplex64", "dtype", "isComplex128", "isBool", "convert", "x", "isc64", "ctor", "xbuf", "obuf", "get", "out", "len", "t", "i", "main"]
}
